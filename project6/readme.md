# Google Password Checkup 验证协议实现

## 1. 协议概述

私有交集和（Private Intersection-Sum）协议是一种隐私保护技术，允许两个参与方（P1和P2）在不泄露各自完整数据集的情况下，计算双方数据集中共同元素（交集）所对应数值的总和。本实现基于判定性Diffie-Hellman（DDH）假设，通过密码学机制确保数据隐私性。

## 2. 算法流程

### 2.1 参与方与数据
- **P1**：持有元素集合V = {v₁, v₂, ..., vₙ}（如用户ID列表）
- **P2**：持有元素-值对集合W = {(w₁, t₁), (w₂, t₂), ..., (wₘ, tₘ)}（如用户ID及其对应的消费金额）

### 2.2 协议执行步骤

1. **初始化阶段**
   - 双方协商使用相同的素数阶群G
   - P1生成私钥k₁，P2生成私钥k₂
   - P2生成加法同态加密方案的密钥对(pk, sk)，并将公钥pk发送给P1

2. **第一轮通信（P1 → P2）**
   - P1对每个元素vᵢ计算H(vᵢ)^k₁（H为哈希函数）
   - 打乱计算结果顺序后发送给P2

3. **第二轮通信（P2 → P1）**
   - P2对P1发送的每个元素计算H(vᵢ)^(k₁k₂)，形成集合Z
   - P2对自己的每个元素(wⱼ, tⱼ)计算H(wⱼ)^k₂并使用公钥加密tⱼ
   - 打乱上述结果顺序后发送给P1

4. **第三轮通信（P1 → P2）**
   - P1对P2发送的H(wⱼ)^k₂计算H(wⱼ)^(k₁k₂)
   - 找出与集合Z匹配的元素（即交集元素）
   - 使用同态加密的加法特性计算交集元素对应tⱼ的加密和
   - 将加密结果发送给P2

5. **结果解密**
   - P2使用私钥sk解密得到最终的交集和

## 3. 函数说明

### 3.1 素数生成与验证函数

#### 3.1.1 `generate_prime(bits=256)`
- 生成指定比特长度的大素数，用于构造密码学群

#### 3.1.2 `is_prime(n, k=5)`
- 使用Miller-Rabin算法进行素性测试

### 3.2 哈希与群映射函数

#### 3.2.1 `hash_to_group(element, prime)`
- 将输入元素映射到指定素数阶群中的元素

### 3.3 加法同态加密类 `AdditiveHomomorphicEncryption`

实现改进版Paillier加密方案，支持加法同态操作，修复了模逆元计算错误

#### 3.3.1 `__init__(self, key_size=256)`
- 初始化同态加密方案，生成密钥对

#### 3.3.2 `lcm(self, a, b)`
- 计算两个数的最小公倍数

#### 3.3.3 `gcd(self, a, b)`
- 使用欧几里得算法计算最大公约数

#### 3.3.4 `encrypt(self, m, public_key=None)`

#### 3.3.5 `decrypt(self, c, private_key=None)`

#### 3.3.6 `add(c1, c2, n)`
- 实现密文的同态加法

### 3.4 参与方P1类 `Party1`

#### 3.4.1 `__init__(self, elements, prime=None)`
- 初始化P1，生成P1的私有密钥k₁（1 < k₁ < prime-1）

#### 3.4.2 `round1(self)`
- 执行协议第一轮操作，对每个元素进行哈希和指数运算，打乱顺序以增强隐私性

#### 3.4.3 `round3(self, p2_round2_output, z_set)`
- 执行协议第三轮操作，计算H(wⱼ)^(k₁k₂)并与Z集合比对找到交集；使用同态加法计算交集元素对应数值的和

### 3.5 参与方P2类 `Party2`

#### 3.5.1 `__init__(self, elements_with_values, prime=None)`
- 生成P2的私有密钥k₂，初始化同态加密方案

#### 3.5.2 `setup(self)`
- 协议初始化，提供同态加密公钥

#### 3.5.3 `round2(self, p1_round1_output)`
- 执行协议第二轮操作,处理P1发送的元素生成Z集合；处理自己的元素并加密数值，打乱顺序后发送




