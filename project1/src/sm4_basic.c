#include <stdint.h>
#include <string.h>

// SM4常量和S盒
static const uint32_t FK[4] = {
    0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC
};

static const uint32_t CK[32] = {
    0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,
    0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,
    0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,
    0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,
    0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,
    0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,
    0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,
    0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279
};

static const uint8_t Sbox[256] = {
    0xD6,0x90,0xE9,0xFE,0xCC,0xE1,0x3D,0xB7,0x16,0xB6,0x14,0xC2,0x28,0xFB,0x2C,0x05,
    0x2B,0x67,0x9A,0x76,0x2A,0xBE,0x04,0xC3,0xAA,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
    0x9C,0x42,0x50,0xF4,0x91,0xEF,0x98,0x7A,0x33,0x54,0x0B,0x43,0xED,0xCF,0xAC,0x62,
    0xE4,0xB3,0x1C,0xA9,0xC9,0x08,0xE8,0x95,0x80,0xDF,0x94,0xFA,0x75,0x8F,0x3F,0xA6,
    0x47,0x07,0xA7,0xFC,0xF3,0x73,0x17,0xBA,0x83,0x59,0x3C,0x19,0xE6,0x85,0x4F,0xA8,
    0x68,0x6B,0x81,0xB2,0x71,0x64,0xDA,0x8B,0xF8,0xEB,0x0F,0x4B,0x70,0x56,0x9D,0x35,
    0x1E,0x24,0x0E,0x5E,0x63,0x58,0xD1,0xA2,0x25,0x22,0x7C,0x3B,0x01,0x21,0x78,0x87,
    0xD4,0x00,0x46,0x57,0x9F,0xD3,0x27,0x52,0x4C,0x36,0x02,0xE7,0xA0,0xC4,0xC8,0x9E,
    0xEA,0xBF,0x8A,0xD2,0x40,0xC7,0x31,0xB1,0x12,0x10,0x59,0x29,0x72,0xC0,0x3B,0xEE,
    0x7B,0xFB,0x7E,0x03,0x1B,0x11,0x0C,0x55,0x6D,0x8D,0x74,0x1F,0x4D,0x2D,0x8E,0x4E,
    0x09,0xCF,0x2F,0x5B,0x66,0xC1,0x1A,0x79,0x6D,0xCD,0x8C,0x9A,0x6E,0x73,0x6F,0xAC,
    0xAA,0xD8,0x32,0x64,0x81,0x90,0x41,0x58,0x28,0x92,0xDA,0x3A,0x0A,0x49,0x06,0x24
};

// 字节替换函数
static uint32_t sm4_sbox(uint32_t in) {
    uint8_t *p = (uint8_t *)&in;
    p[0] = Sbox[p[0]];
    p[1] = Sbox[p[1]];
    p[2] = Sbox[p[2]];
    p[3] = Sbox[p[3]];
    return in;
}

// 线性变换L
static uint32_t sm4_L(uint32_t x) {
    return x ^ ((x << 2) | (x >> 30)) ^ ((x << 10) | (x >> 22)) ^ 
           ((x << 18) | (x >> 14)) ^ ((x << 24) | (x >> 8));
}

// 轮函数F
static uint32_t sm4_F(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3, uint32_t rk) {
    uint32_t t = x1 ^ x2 ^ x3 ^ rk;
    t = sm4_sbox(t);
    return x0 ^ sm4_L(t);
}

// 密钥扩展函数
static void sm4_key_extension(const uint8_t *key, uint32_t *rk) {
    uint32_t MK[4];
    uint32_t K[36];
    int i;
    
    // 将128位密钥转换为4个32位字
    memcpy(MK, key, 16);
    
    // 初始化密钥
    K[0] = MK[0] ^ FK[0];
    K[1] = MK[1] ^ FK[1];
    K[2] = MK[2] ^ FK[2];
    K[3] = MK[3] ^ FK[3];
    
    // 生成轮密钥
    for (i = 0; i < 32; i++) {
        uint32_t t = K[i+1] ^ K[i+2] ^ K[i+3] ^ CK[i];
        t = sm4_sbox(t);
        K[i+4] = K[i] ^ (t ^ ((t << 13) | (t >> 19)) ^ ((t << 23) | (t >> 9)));
        rk[i] = K[i+4];
    }
}

// SM4加密函数
void sm4_encrypt(const uint8_t *key, const uint8_t *input, uint8_t *output) {
    uint32_t X[36];
    uint32_t rk[32];
    int i;
    
    // 密钥扩展
    sm4_key_extension(key, rk);
    
    // 初始化输入
    memcpy(X, input, 16);
    
    // 32轮迭代
    for (i = 0; i < 32; i++) {
        X[i+4] = sm4_F(X[i], X[i+1], X[i+2], X[i+3], rk[i]);
    }
    
    // 输出变换
    ((uint32_t*)output)[0] = X[35];
    ((uint32_t*)output)[1] = X[34];
    ((uint32_t*)output)[2] = X[33];
    ((uint32_t*)output)[3] = X[32];
}

// SM4解密函数 (与加密类似，只是轮密钥使用顺序相反)
void sm4_decrypt(const uint8_t *key, const uint8_t *input, uint8_t *output) {
    uint32_t X[36];
    uint32_t rk[32];
    int i;
    
    // 密钥扩展
    sm4_key_extension(key, rk);
    
    // 初始化输入
    memcpy(X, input, 16);
    
    // 32轮迭代，使用逆序的轮密钥
    for (i = 0; i < 32; i++) {
        X[i+4] = sm4_F(X[i], X[i+1], X[i+2], X[i+3], rk[31-i]);
    }
    
    // 输出变换
    ((uint32_t*)output)[0] = X[35];
    ((uint32_t*)output)[1] = X[34];
    ((uint32_t*)output)[2] = X[33];
    ((uint32_t*)output)[3] = X[32];
}
