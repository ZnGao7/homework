#include <stdint.h>
#include <string.h>
#include <stdlib.h>

// 预计算T表
static uint32_t T_table[256][256][256][256];
static int T_initialized = 0;

// SM4常量和S盒 (与基础实现相同)
static const uint32_t FK[4] = {
    0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC
};

static const uint32_t CK[32] = {
    0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,
    0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,
    0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,
    0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,
    0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,
    0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,
    0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,
    0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279
};

static const uint8_t Sbox[256] = {
    0xD6,0x90,0xE9,0xFE,0xCC,0xE1,0x3D,0xB7,0x16,0xB6,0x14,0xC2,0x28,0xFB,0x2C,0x05,
    0x2B,0x67,0x9A,0x76,0x2A,0xBE,0x04,0xC3,0xAA,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
    0x9C,0x42,0x50,0xF4,0x91,0xEF,0x98,0x7A,0x33,0x54,0x0B,0x43,0xED,0xCF,0xAC,0x62,
    0xE4,0xB3,0x1C,0xA9,0xC9,0x08,0xE8,0x95,0x80,0xDF,0x94,0xFA,0x75,0x8F,0x3F,0xA6,
    0x47,0x07,0xA7,0xFC,0xF3,0x73,0x17,0xBA,0x83,0x59,0x3C,0x19,0xE6,0x85,0x4F,0xA8,
    0x68,0x6B,0x81,0xB2,0x71,0x64,0xDA,0x8B,0xF8,0xEB,0x0F,0x4B,0x70,0x56,0x9D,0x35,
    0x1E,0x24,0x0E,0x5E,0x63,0x58,0xD1,0xA2,0x25,0x22,0x7C,0x3B,0x01,0x21,0x78,0x87,
    0xD4,0x00,0x46,0x57,0x9F,0xD3,0x27,0x52,0x4C,0x36,0x02,0xE7,0xA0,0xC4,0xC8,0x9E,
    0xEA,0xBF,0x8A,0xD2,0x40,0xC7,0x31,0xB1,0x12,0x10,0x59,0x29,0x72,0xC0,0x3B,0xEE,
    0x7B,0xFB,0x7E,0x03,0x1B,0x11,0x0C,0x55,0x6D,0x8D,0x74,0x1F,0x4D,0x2D,0x8E,0x4E,
    0x09,0xCF,0x2F,0x5B,0x66,0xC1,0x1A,0x79,0x6D,0xCD,0x8C,0x9A,0x6E,0x73,0x6F,0xAC,
    0xAA,0xD8,0x32,0x64,0x81,0x90,0x41,0x58,0x28,0x92,0xDA,0x3A,0x0A,0x49,0x06,0x24
};

// 线性变换L
static uint32_t sm4_L(uint32_t x) {
    return x ^ ((x << 2) | (x >> 30)) ^ ((x << 10) | (x >> 22)) ^ 
           ((x << 18) | (x >> 14)) ^ ((x << 24) | (x >> 8));
}

// 初始化T表
static void sm4_init_T_table() {
    if (T_initialized) return;
    
    for (int a = 0; a < 256; a++) {
        for (int b = 0; b < 256; b++) {
            for (int c = 0; c < 256; c++) {
                for (int d = 0; d < 256; d++) {
                    uint32_t val = (Sbox[a] << 24) | (Sbox[b] << 16) | (Sbox[c] << 8) | Sbox[d];
                    T_table[a][b][c][d] = sm4_L(val);
                }
            }
        }
    }
    
    T_initialized = 1;
}

// 轮函数F，使用T表优化
static uint32_t sm4_F_optimized(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3, uint32_t rk) {
    uint32_t t = x1 ^ x2 ^ x3 ^ rk;
    uint8_t *p = (uint8_t *)&t;
    
    // 直接从T表获取预计算的结果
    uint32_t L_result = T_table[p[0]][p[1]][p[2]][p[3]];
    return x0 ^ L_result;
}

// 密钥扩展函数 (与基础实现相同)
static void sm4_key_extension(const uint8_t *key, uint32_t *rk) {
    uint32_t MK[4];
    uint32_t K[36];
    int i;
    
    memcpy(MK, key, 16);
    
    K[0] = MK[0] ^ FK[0];
    K[1] = MK[1] ^ FK[1];
    K[2] = MK[2] ^ FK[2];
    K[3] = MK[3] ^ FK[3];
    
    for (i = 0; i < 32; i++) {
        uint32_t t = K[i+1] ^ K[i+2] ^ K[i+3] ^ CK[i];
        uint8_t *p = (uint8_t *)&t;
        p[0] = Sbox[p[0]];
        p[1] = Sbox[p[1]];
        p[2] = Sbox[p[2]];
        p[3] = Sbox[p[3]];
        K[i+4] = K[i] ^ (t ^ ((t << 13) | (t >> 19)) ^ ((t << 23) | (t >> 9)));
        rk[i] = K[i+4];
    }
}

// 使用T表优化的SM4加密函数
void sm4_encrypt_optimized(const uint8_t *key, const uint8_t *input, uint8_t *output) {
    uint32_t X[36];
    uint32_t rk[32];
    int i;
    
    // 初始化T表
    sm4_init_T_table();
    
    // 密钥扩展
    sm4_key_extension(key, rk);
    
    // 初始化输入
    memcpy(X, input, 16);
    
    // 32轮迭代，使用优化的轮函数
    for (i = 0; i < 32; i++) {
        X[i+4] = sm4_F_optimized(X[i], X[i+1], X[i+2], X[i+3], rk[i]);
    }
    
    // 输出变换
    ((uint32_t*)output)[0] = X[35];
    ((uint32_t*)output)[1] = X[34];
    ((uint32_t*)output)[2] = X[33];
    ((uint32_t*)output)[3] = X[32];
}

// 使用T表优化的SM4解密函数
void sm4_decrypt_optimized(const uint8_t *key, const uint8_t *input, uint8_t *output) {
    uint32_t X[36];
    uint32_t rk[32];
    int i;
    
    // 初始化T表
    sm4_init_T_table();
    
    // 密钥扩展
    sm4_key_extension(key, rk);
    
    // 初始化输入
    memcpy(X, input, 16);
    
    // 32轮迭代，使用逆序的轮密钥
    for (i = 0; i < 32; i++) {
        X[i+4] = sm4_F_optimized(X[i], X[i+1], X[i+2], X[i+3], rk[31-i]);
    }
    
    // 输出变换
    ((uint32_t*)output)[0] = X[35];
    ((uint32_t*)output)[1] = X[34];
    ((uint32_t*)output)[2] = X[33];
    ((uint32_t*)output)[3] = X[32];
}
