#include <stdint.h>
#include <wmmintrin.h>  // 包含AESNI指令

// 使用AESNI指令优化的S盒替换
static __m128i aesni_sbox(__m128i x) {
    // 使用AES指令模拟SM4的S盒替换
    __m128i sbox = _mm_set_epi8(
        0xD6,0x90,0xE9,0xFE,0xCC,0xE1,0x3D,0xB7,0x16,0xB6,0x14,0xC2,0x28,0xFB,0x2C,0x05,
        0x2B,0x67,0x9A,0x76,0x2A,0xBE,0x04,0xC3,0xAA,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
        0x9C,0x42,0x50,0xF4,0x91,0xEF,0x98,0x7A,0x33,0x54,0x0B,0x43,0xED,0xCF,0xAC,0x62,
        0xE4,0xB3,0x1C,0xA9,0xC9,0x08,0xE8,0x95,0x80,0xDF,0x94,0xFA,0x75,0x8F,0x3F,0xA6,
        0x47,0x07,0xA7,0xFC,0xF3,0x73,0x17,0xBA,0x83,0x59,0x3C,0x19,0xE6,0x85,0x4F,0xA8,
        0x68,0x6B,0x81,0xB2,0x71,0x64,0xDA,0x8B,0xF8,0xEB,0x0F,0x4B,0x70,0x56,0x9D,0x35,
        0x1E,0x24,0x0E,0x5E,0x63,0x58,0xD1,0xA2,0x25,0x22,0x7C,0x3B,0x01,0x21,0x78,0x87,
        0xD4,0x00,0x46,0x57,0x9F,0xD3,0x27,0x52,0x4C,0x36,0x02,0xE7,0xA0,0xC4,0xC8,0x9E,
        0xEA,0xBF,0x8A,0xD2,0x40,0xC7,0x38,0xB5,0xA3,0xF7,0xF2,0xCE,0xF9,0x61,0x15,0xA1,
        0xE0,0xAE,0x5D,0xA4,0x9B,0x34,0x1A,0x55,0xAD,0x93,0x32,0x30,0xF5,0x8C,0xB1,0xE3,
        0x1D,0x29,0xC5,0x89,0x6F,0xB9,0x0D,0x03,0xDF,0x45,0x0C,0x53,0x6A,0x0A,0x00,0x12,
        0xBD,0x09,0x8E,0x9E,0x37,0xE6,0x20,0xAA,0x18,0xBE,0x1B,0xFC,0x56,0x3E,0x4D,0x0B,
        0x2F,0xBA,0x55,0xA0,0x86,0xC1,0x1D,0x73,0x16,0x59,0x2B,0x0C,0x63,0x81,0xB7,0x67,
        0x9E,0x00,0x52,0x3B,0x9A,0x05,0x90,0x40,0x5C,0x60,0xD5,0x9B,0x6B,0x7B,0x6E,0x48,
        0x5B,0xEE,0x38,0x83,0x31,0x88,0x99,0x87,0x3A,0x8D,0x41,0x42,0x1E,0x04,0x6D,0x5E,
        0x15,0x46,0x57,0xA3,0x27,0x1F,0x36,0x91,0xCC,0x1B,0xED,0x51,0x22,0xF8,0x2C,0x5B
    );
    
    // 使用AES的查表指令进行字节替换
    return _mm_shuffle_epi8(sbox, x);
}

// 使用AESNI优化的线性变换L
static __m128i aesni_L(__m128i x) {
    // 利用AESNI的移位和异或指令实现L变换
    __m128i x2 = _mm_slli_epi32(x, 2);
    __m128i x10 = _mm_slli_epi32(x, 10);
    __m128i x18 = _mm_slli_epi32(x, 18);
    __m128i x24 = _mm_slli_epi32(x, 24);
    
    __m128i x_30 = _mm_srli_epi32(x, 30);
    __m128i x_22 = _mm_slli_epi32(_mm_srli_epi32(x, 22), 8);
    __m128i x_14 = _mm_slli_epi32(_mm_srli_epi32(x, 14), 16);
    __m128i x_6 = _mm_slli_epi32(_mm_srli_epi32(x, 6), 24);
    
    return _mm_xor_si128(x, _mm_xor_si128(x2, _mm_xor_si128(x10, 
           _mm_xor_si128(x18, _mm_xor_si128(x24, _mm_xor_si128(x_30, 
           _mm_xor_si128(x_22, _mm_xor_si128(x_14, x_6)))))));
}

// 使用AESNI优化的T函数
static __m128i aesni_T(__m128i x) {
    return aesni_L(aesni_sbox(x));
}

// 使用AESNI优化的SM4加密函数
void sm4_encrypt_aesni(const uint8_t *key, const uint8_t *input, uint8_t *output) {
    // 加载密钥和明文到128位寄存器
    __m128i key_vec = _mm_loadu_si128((const __m128i*)key);
    __m128i input_vec = _mm_loadu_si128((const __m128i*)input);
    
    // 密钥扩展（使用AESNI指令）
    __m128i rk[32];
    sm4_key_expansion_aesni(key_vec, rk);
    
    // 初始化状态
    __m128i x0, x1, x2, x3, temp;
    x0 = _mm_slli_si128(input_vec, 0);  // 提取第一个32位字
    x1 = _mm_slli_si128(input_vec, 4);  // 提取第二个32位字
    x2 = _mm_slli_si128(input_vec, 8);  // 提取第三个32位字
    x3 = _mm_slli_si128(input_vec, 12); // 提取第四个32位字
    
    // 32轮迭代
    for (int i = 0; i < 32; i++) {
        temp = _mm_xor_si128(x1, _mm_xor_si128(x2, _mm_xor_si128(x3, rk[i])));
        temp = aesni_T(temp);
        temp = _mm_xor_si128(temp, x0);
        
        // 轮转状态
        x0 = x1;
        x1 = x2;
        x2 = x3;
        x3 = temp;
    }
    
    // 组合结果并输出
    __m128i output_vec = _mm_or_si128(
        _mm_srli_si128(x3, 0),  // 第一个32位字
        _mm_or_si128(
            _mm_srli_si128(x2, 4),  // 第二个32位字
            _mm_or_si128(
                _mm_srli_si128(x1, 8),  // 第三个32位字
                _mm_srli_si128(x0, 12)  // 第四个32位字
            )
        )
    );
    
    _mm_storeu_si128((__m128i*)output, output_vec);
}
